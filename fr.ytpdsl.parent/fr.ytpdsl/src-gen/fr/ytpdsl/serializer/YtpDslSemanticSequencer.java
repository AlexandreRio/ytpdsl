/*
 * generated by Xtext 2.18.0.M3
 */
package fr.ytpdsl.serializer;

import com.google.inject.Inject;
import fr.ytpdsl.services.YtpDslGrammarAccess;
import fr.ytpdsl.ytpDsl.BlackWhiteFilter;
import fr.ytpdsl.ytpDsl.FlipFilter;
import fr.ytpdsl.ytpDsl.GeneratorInformation;
import fr.ytpdsl.ytpDsl.ImageDescription;
import fr.ytpdsl.ytpDsl.Media;
import fr.ytpdsl.ytpDsl.NegateFilter;
import fr.ytpdsl.ytpDsl.VideoDescription;
import fr.ytpdsl.ytpDsl.VideoLibrary;
import fr.ytpdsl.ytpDsl.VideoText;
import fr.ytpdsl.ytpDsl.YtpDslPackage;
import fr.ytpdsl.ytpDsl.YtpModel;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class YtpDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private YtpDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == YtpDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case YtpDslPackage.BLACK_WHITE_FILTER:
				sequence_BlackWhiteFilter(context, (BlackWhiteFilter) semanticObject); 
				return; 
			case YtpDslPackage.FLIP_FILTER:
				sequence_FlipFilter(context, (FlipFilter) semanticObject); 
				return; 
			case YtpDslPackage.GENERATOR_INFORMATION:
				sequence_GeneratorInformation(context, (GeneratorInformation) semanticObject); 
				return; 
			case YtpDslPackage.IMAGE_DESCRIPTION:
				sequence_ImageDescription(context, (ImageDescription) semanticObject); 
				return; 
			case YtpDslPackage.MEDIA:
				sequence_Media(context, (Media) semanticObject); 
				return; 
			case YtpDslPackage.NEGATE_FILTER:
				sequence_NegateFilter(context, (NegateFilter) semanticObject); 
				return; 
			case YtpDslPackage.VIDEO_DESCRIPTION:
				sequence_VideoDescription(context, (VideoDescription) semanticObject); 
				return; 
			case YtpDslPackage.VIDEO_LIBRARY:
				sequence_VideoLibrary(context, (VideoLibrary) semanticObject); 
				return; 
			case YtpDslPackage.VIDEO_TEXT:
				sequence_VideoText(context, (VideoText) semanticObject); 
				return; 
			case YtpDslPackage.YTP_MODEL:
				sequence_YtpModel(context, (YtpModel) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Filter returns BlackWhiteFilter
	 *     BlackWhiteFilter returns BlackWhiteFilter
	 *
	 * Constraint:
	 *     {BlackWhiteFilter}
	 */
	protected void sequence_BlackWhiteFilter(ISerializationContext context, BlackWhiteFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Filter returns FlipFilter
	 *     FlipFilter returns FlipFilter
	 *
	 * Constraint:
	 *     (orientation='h' | orientation='horizontal' | orientation='v' | orientation='vertical')
	 */
	protected void sequence_FlipFilter(ISerializationContext context, FlipFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GeneratorInformation returns GeneratorInformation
	 *
	 * Constraint:
	 *     (
	 *         authorName=STRING 
	 *         version=STRING? 
	 *         creationDate=STRING? 
	 *         ffmpeg=STRING 
	 *         ffprobe=STRING 
	 *         library+=VideoLibrary*
	 *     )
	 */
	protected void sequence_GeneratorInformation(ISerializationContext context, GeneratorInformation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MediaDescription returns ImageDescription
	 *     ImageDescription returns ImageDescription
	 *
	 * Constraint:
	 *     (imageid=ID? location=STRING (top=STRING bottom=STRING)?)
	 */
	protected void sequence_ImageDescription(ISerializationContext context, ImageDescription semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Media returns Media
	 *
	 * Constraint:
	 *     description=MediaDescription
	 */
	protected void sequence_Media(ISerializationContext context, Media semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, YtpDslPackage.Literals.MEDIA__DESCRIPTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, YtpDslPackage.Literals.MEDIA__DESCRIPTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMediaAccess().getDescriptionMediaDescriptionParserRuleCall_1_0(), semanticObject.getDescription());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Filter returns NegateFilter
	 *     NegateFilter returns NegateFilter
	 *
	 * Constraint:
	 *     {NegateFilter}
	 */
	protected void sequence_NegateFilter(ISerializationContext context, NegateFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MediaDescription returns VideoDescription
	 *     VideoDescription returns VideoDescription
	 *
	 * Constraint:
	 *     (
	 *         videoid=ID? 
	 *         location=STRING 
	 *         duration=INT? 
	 *         probability=INT? 
	 *         description=STRING? 
	 *         filter=Filter? 
	 *         text=VideoText?
	 *     )
	 */
	protected void sequence_VideoDescription(ISerializationContext context, VideoDescription semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VideoLibrary returns VideoLibrary
	 *
	 * Constraint:
	 *     (folder=STRING extension+=STRING+)
	 */
	protected void sequence_VideoLibrary(ISerializationContext context, VideoLibrary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VideoText returns VideoText
	 *
	 * Constraint:
	 *     (content=STRING position=Position color=STRING? size=INT?)
	 */
	protected void sequence_VideoText(ISerializationContext context, VideoText semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     YtpModel returns YtpModel
	 *
	 * Constraint:
	 *     (information=GeneratorInformation? medias+=Media+)
	 */
	protected void sequence_YtpModel(ISerializationContext context, YtpModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
